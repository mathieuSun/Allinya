{
  "version": 3,
  "sources": ["../../api/sessions/accept.ts"],
  "sourcesContent": ["import type { VercelRequest, VercelResponse } from '@vercel/node';\nimport { z } from 'zod';\nimport { handleCors } from '../_lib/cors';\nimport { requireAuth } from '../_lib/auth';\nimport { storage } from '../_lib/database';\n\nexport default async function handler(req: VercelRequest, res: VercelResponse) {\n  if (handleCors(req, res)) return;\n  \n  if (req.method !== 'POST') {\n    return res.status(405).json({ error: 'Method not allowed' });\n  }\n  \n  try {\n    const auth = await requireAuth(req, res);\n    if (!auth) return;\n    \n    const body = z.object({\n      sessionId: z.string().uuid(),\n      action: z.enum(['accept', 'acknowledge', 'ready', 'reject']).optional()\n    }).parse(req.body);\n\n    const sessionId = body.sessionId;\n    const action = body.action || 'accept';\n    \n    const userId = auth.userId;\n    const session = await storage.getSession(sessionId);\n\n    if (!session) {\n      return res.status(404).json({ error: 'Session not found' });\n    }\n\n    // Handle different actions based on the 'action' parameter\n    switch (action) {\n      case 'acknowledge':\n        // Verify user is the practitioner\n        if (userId !== session.practitionerId) {\n          return res.status(403).json({ error: 'Only the practitioner can acknowledge the session' });\n        }\n\n        // Verify session is in waiting phase\n        if (session.phase !== 'waiting') {\n          return res.status(400).json({ error: 'Session is not in waiting phase' });\n        }\n\n        // Update session to mark practitioner acknowledged\n        const acknowledgedSession = await storage.updateSession(sessionId, {\n          acknowledgedPractitioner: true\n        });\n\n        res.json({ \n          success: true,\n          message: 'Session acknowledged. Guest has been notified.',\n          session: acknowledgedSession\n        });\n        break;\n        \n      case 'ready':\n        // Handle ready state - determine if guest or practitioner\n        const isGuest = userId === session.guestId;\n        const isPractitioner = userId === session.practitionerId;\n        \n        if (!isGuest && !isPractitioner) {\n          return res.status(403).json({ error: 'Not a session participant' });\n        }\n\n        // For practitioner, ensure they have acknowledged first\n        if (isPractitioner && !session.acknowledgedPractitioner) {\n          return res.status(400).json({ \n            error: 'Please acknowledge the session request first' \n          });\n        }\n\n        const updates: any = {};\n        \n        if (isGuest) {\n          updates.readyGuest = true;\n        } else {\n          updates.readyPractitioner = true;\n        }\n\n        // Check if both ready, transition to live\n        const bothReady = isGuest\n          ? session.readyPractitioner === true\n          : session.readyGuest === true;\n\n        if (bothReady && session.phase === 'waiting') {\n          // Auto-transition to live phase when both parties are ready\n          updates.phase = 'live';\n          updates.liveStartedAt = new Date().toISOString();\n          \n          console.log(`Session ${sessionId} auto-transitioning to live phase - both parties ready`);\n        }\n\n        const readySession = await storage.updateSession(sessionId, updates);\n        res.json(readySession);\n        break;\n        \n      case 'reject':\n        // Verify user is the practitioner\n        if (userId !== session.practitionerId) {\n          return res.status(403).json({ error: 'Only the practitioner can reject the session' });\n        }\n\n        // Verify session is in waiting phase\n        if (session.phase !== 'waiting') {\n          return res.status(400).json({ error: 'Session is not in waiting phase' });\n        }\n\n        // Update session phase to ended\n        const rejectedSession = await storage.updateSession(sessionId, {\n          phase: 'ended'\n        });\n\n        // Mark practitioner as not in service\n        await storage.updatePractitioner(session.practitionerId, { inService: false });\n\n        res.json(rejectedSession);\n        break;\n        \n      case 'accept':\n      default:\n        // Default accept behavior (from practitioner dashboard)\n        // Verify user is the practitioner\n        if (userId !== session.practitionerId) {\n          return res.status(403).json({ error: 'Only the practitioner can accept the session' });\n        }\n\n        // Verify session is in waiting phase\n        if (session.phase !== 'waiting') {\n          return res.status(400).json({ error: 'Session is not in waiting phase' });\n        }\n\n        // Mark practitioner as acknowledged and ready when accepting from dashboard\n        const acceptedSession = await storage.updateSession(sessionId, {\n          acknowledgedPractitioner: true,\n          readyPractitioner: true,\n        });\n\n        res.json(acceptedSession);\n        break;\n    }\n  } catch (error: any) {\n    console.error('Session action error:', error);\n    if (error.name === 'ZodError') {\n      return res.status(400).json({ error: 'Invalid input', details: error.errors });\n    }\n    res.status(400).json({ error: error.message || 'Failed to process session action' });\n  }\n}"],
  "mappings": "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",
  "names": []
}
