{
  "version": 3,
  "sources": ["../../api/sessions/create.ts"],
  "sourcesContent": ["import type { VercelRequest, VercelResponse } from '@vercel/node';\nimport { z } from 'zod';\nimport { randomUUID } from 'crypto';\nimport { handleCors } from '../_lib/cors';\nimport { requireAuth } from '../_lib/auth';\nimport { storage } from '../_lib/database';\n\nexport default async function handler(req: VercelRequest, res: VercelResponse) {\n  if (handleCors(req, res)) return;\n  \n  if (req.method !== 'POST') {\n    return res.status(405).json({ error: 'Method not allowed' });\n  }\n  \n  try {\n    const auth = await requireAuth(req, res);\n    if (!auth) return;\n    \n    console.log('Session start request:', req.body);\n    \n    const { practitionerId, liveSeconds } = z.object({\n      practitionerId: z.string().uuid(),\n      liveSeconds: z.number().int().positive(),\n    }).parse(req.body);\n\n    const guestId = auth.userId;\n    console.log('Guest ID:', guestId, 'Practitioner ID:', practitionerId);\n\n    // Verify guest role\n    const guest = await storage.getProfile(guestId);\n    if (!guest || guest.role !== 'guest') {\n      console.error('User is not a guest:', guest);\n      return res.status(403).json({ error: 'Only guests can start sessions' });\n    }\n\n    // Verify practitioner exists and is online\n    const practitioner = await storage.getPractitioner(practitionerId);\n    console.log('Practitioner status:', practitioner);\n    if (!practitioner || !practitioner.isOnline) {\n      return res.status(400).json({ error: 'Practitioner is not available' });\n    }\n\n    // Create session\n    const sessionId = randomUUID();\n    const agoraChannel = `sess_${sessionId.substring(0, 8)}`;\n    \n    console.log('Creating session with ID:', sessionId);\n    \n    const session = await storage.createSession({\n      practitionerId: practitionerId,\n      guestId: guestId,\n      phase: 'waiting',\n      liveSeconds: liveSeconds,\n      practitionerReady: false,\n      guestReady: false,\n      acknowledgedPractitioner: false,\n      agoraChannel: agoraChannel,\n    });\n\n    console.log('Session created:', session);\n\n    // Mark practitioner as in service\n    await storage.updatePractitioner(practitionerId, { inService: true });\n\n    res.json({ sessionId: session.id });\n  } catch (error: any) {\n    console.error('Error creating session:', error);\n    res.status(400).json({ error: error.message });\n  }\n}"],
  "mappings": "AACA,SAAS,SAAS;AAClB,SAAS,kBAAkB;AAC3B,SAAS,kBAAkB;AAC3B,SAAS,mBAAmB;AAC5B,SAAS,eAAe;AAExB,eAAO,QAA+B,KAAoB,KAAqB;AAC7E,MAAI,WAAW,KAAK,GAAG,EAAG;AAE1B,MAAI,IAAI,WAAW,QAAQ;AACzB,WAAO,IAAI,OAAO,GAAG,EAAE,KAAK,EAAE,OAAO,qBAAqB,CAAC;AAAA,EAC7D;AAEA,MAAI;AACF,UAAM,OAAO,MAAM,YAAY,KAAK,GAAG;AACvC,QAAI,CAAC,KAAM;AAEX,YAAQ,IAAI,0BAA0B,IAAI,IAAI;AAE9C,UAAM,EAAE,gBAAgB,YAAY,IAAI,EAAE,OAAO;AAAA,MAC/C,gBAAgB,EAAE,OAAO,EAAE,KAAK;AAAA,MAChC,aAAa,EAAE,OAAO,EAAE,IAAI,EAAE,SAAS;AAAA,IACzC,CAAC,EAAE,MAAM,IAAI,IAAI;AAEjB,UAAM,UAAU,KAAK;AACrB,YAAQ,IAAI,aAAa,SAAS,oBAAoB,cAAc;AAGpE,UAAM,QAAQ,MAAM,QAAQ,WAAW,OAAO;AAC9C,QAAI,CAAC,SAAS,MAAM,SAAS,SAAS;AACpC,cAAQ,MAAM,wBAAwB,KAAK;AAC3C,aAAO,IAAI,OAAO,GAAG,EAAE,KAAK,EAAE,OAAO,iCAAiC,CAAC;AAAA,IACzE;AAGA,UAAM,eAAe,MAAM,QAAQ,gBAAgB,cAAc;AACjE,YAAQ,IAAI,wBAAwB,YAAY;AAChD,QAAI,CAAC,gBAAgB,CAAC,aAAa,UAAU;AAC3C,aAAO,IAAI,OAAO,GAAG,EAAE,KAAK,EAAE,OAAO,gCAAgC,CAAC;AAAA,IACxE;AAGA,UAAM,YAAY,WAAW;AAC7B,UAAM,eAAe,QAAQ,UAAU,UAAU,GAAG,CAAC,CAAC;AAEtD,YAAQ,IAAI,6BAA6B,SAAS;AAElD,UAAM,UAAU,MAAM,QAAQ,cAAc;AAAA,MAC1C;AAAA,MACA;AAAA,MACA,OAAO;AAAA,MACP;AAAA,MACA,mBAAmB;AAAA,MACnB,YAAY;AAAA,MACZ,0BAA0B;AAAA,MAC1B;AAAA,IACF,CAAC;AAED,YAAQ,IAAI,oBAAoB,OAAO;AAGvC,UAAM,QAAQ,mBAAmB,gBAAgB,EAAE,WAAW,KAAK,CAAC;AAEpE,QAAI,KAAK,EAAE,WAAW,QAAQ,GAAG,CAAC;AAAA,EACpC,SAAS,OAAY;AACnB,YAAQ,MAAM,2BAA2B,KAAK;AAC9C,QAAI,OAAO,GAAG,EAAE,KAAK,EAAE,OAAO,MAAM,QAAQ,CAAC;AAAA,EAC/C;AACF;",
  "names": []
}
