{
  "version": 3,
  "sources": ["../../api/_lib/supabase.ts"],
  "sourcesContent": ["import { createClient } from '@supabase/supabase-js';\nimport { randomUUID } from 'crypto';\nimport { supabaseConfig } from './config';\n\n// Create Supabase client with service role key for backend operations\nexport const supabase = createClient(supabaseConfig.url, supabaseConfig.serviceRoleKey, {\n  db: {\n    schema: 'public'\n  },\n  global: {\n    headers: {\n      'Cache-Control': 'no-cache',\n      'Prefer': 'return=representation'\n    }\n  }\n});\n\n// Create admin client for storage operations\nexport const supabaseAdmin = createClient(\n  supabaseConfig.url,\n  supabaseConfig.serviceRoleKey,\n  {\n    auth: {\n      autoRefreshToken: false,\n      persistSession: false\n    }\n  }\n);\n\n// Storage bucket names\nexport type StorageBucket = 'avatars' | 'gallery' | 'videos';\n\n// Supabase Storage Service\nclass SupabaseStorageService {\n  private client = supabaseAdmin;\n\n  /**\n   * Get signed upload URL for a file\n   * Returns both the upload URL and the final public URL\n   */\n  async getUploadUrl(\n    bucket: StorageBucket,\n    userId: string\n  ): Promise<{ uploadUrl: string; publicUrl: string; fileName: string }> {\n    // Generate unique filename with user ID prefix\n    const fileId = randomUUID();\n    const fileName = `${userId}/${fileId}`;\n    \n    // Create signed upload URL (valid for 15 minutes)\n    const { data, error } = await this.client.storage\n      .from(bucket)\n      .createSignedUploadUrl(fileName);\n    \n    if (error || !data) {\n      throw new Error(`Failed to create upload URL: ${error?.message || 'Unknown error'}`);\n    }\n    \n    // Get the public URL that will be accessible after upload\n    const { data: urlData } = this.client.storage\n      .from(bucket)\n      .getPublicUrl(fileName);\n    \n    return {\n      uploadUrl: data.signedUrl,\n      publicUrl: urlData.publicUrl,\n      fileName\n    };\n  }\n\n  /**\n   * Delete a file from storage\n   */\n  async deleteFile(bucket: StorageBucket, fileName: string): Promise<void> {\n    const { error } = await this.client.storage\n      .from(bucket)\n      .remove([fileName]);\n    \n    if (error) {\n      throw new Error(`Failed to delete file: ${error.message}`);\n    }\n  }\n\n  /**\n   * Upload a file directly from server (for migrations or admin operations)\n   */\n  async uploadFile(\n    bucket: StorageBucket,\n    fileName: string,\n    file: Buffer | Blob,\n    contentType?: string\n  ): Promise<string> {\n    const { data, error } = await this.client.storage\n      .from(bucket)\n      .upload(fileName, file, {\n        contentType,\n        upsert: true\n      });\n    \n    if (error) {\n      throw new Error(`Failed to upload file: ${error.message}`);\n    }\n    \n    // Get public URL\n    const { data: urlData } = this.client.storage\n      .from(bucket)\n      .getPublicUrl(fileName);\n    \n    return urlData.publicUrl;\n  }\n\n  /**\n   * List files in a bucket for a specific user\n   */\n  async listUserFiles(bucket: StorageBucket, userId: string): Promise<string[]> {\n    const { data, error } = await this.client.storage\n      .from(bucket)\n      .list(userId);\n    \n    if (error) {\n      throw new Error(`Failed to list files: ${error.message}`);\n    }\n    \n    return (data || []).map(file => {\n      const { data: urlData } = this.client.storage\n        .from(bucket)\n        .getPublicUrl(`${userId}/${file.name}`);\n      return urlData.publicUrl;\n    });\n  }\n\n  /**\n   * Get public URL for an existing file\n   */\n  getPublicUrl(bucket: StorageBucket, fileName: string): string {\n    const { data } = this.client.storage\n      .from(bucket)\n      .getPublicUrl(fileName);\n    \n    return data.publicUrl;\n  }\n\n  /**\n   * Initialize storage buckets on startup\n   */\n  async initializeBuckets(): Promise<void> {\n    const buckets = [\n      { name: 'avatars' as StorageBucket, public: true },\n      { name: 'gallery' as StorageBucket, public: true },\n      { name: 'videos' as StorageBucket, public: true }\n    ];\n\n    for (const bucket of buckets) {\n      try {\n        // First check if bucket exists\n        const { data: existingBucket } = await this.client.storage.getBucket(bucket.name);\n        \n        if (existingBucket) {\n          console.log(`\u2139\uFE0F Storage bucket already exists: ${bucket.name}`);\n          continue;\n        }\n        \n        // Create the bucket with appropriate settings\n        const { error } = await this.client.storage\n          .createBucket(bucket.name, { \n            public: bucket.public,\n            // Don't set file size limits here - handle per upload\n            allowedMimeTypes: bucket.name === 'videos' \n              ? ['video/mp4', 'video/mpeg', 'video/quicktime', 'video/x-ms-wmv', 'video/x-msvideo', 'video/webm']\n              : ['image/jpeg', 'image/png', 'image/gif', 'image/webp', 'image/svg+xml']\n          });\n        \n        if (error) {\n          console.error(`Failed to create bucket ${bucket.name}:`, error);\n        } else {\n          console.log(`\u2705 Storage bucket created: ${bucket.name}`);\n        }\n      } catch (error) {\n        console.error(`Error handling bucket ${bucket.name}:`, error);\n      }\n    }\n  }\n}\n\nexport const supabaseStorage = new SupabaseStorageService();"],
  "mappings": "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",
  "names": []
}
