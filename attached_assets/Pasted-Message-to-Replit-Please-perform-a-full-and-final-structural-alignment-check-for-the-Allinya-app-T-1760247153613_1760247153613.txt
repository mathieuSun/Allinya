Message to Replit

Please perform a full and final structural alignment check for the Allinya app. The goal is absolute coherence â€” every file, function, database field, and environment variable must speak the exact same unified language, following the rules below. This must be verified across the entire app (frontend, backend, database, API, and schema). Any inconsistencies should be corrected immediately, and the SQL schema regenerated cleanly to match.

â¸»

ðŸ”· Global Structural & Naming Conventions (Absolute Truth)
	1.	UUID Everywhere
	â€¢	Every tableâ€™s id, foreign key, and relationship column must use UUID.
	â€¢	No serial, int, or auto-increment fields.
	â€¢	All data relationships (sessions, profiles, reviews, media, etc.) must strictly use UUID references.
	â€¢	Verify that every Supabase migration and relation enforces UUIDs consistently.
	2.	Naming Consistency
	â€¢	File, folder, route, and URL names â†’ kebab-case (kml case).
Example: /waiting-room, /live-video, /start-session.
	â€¢	Code variables, functions, and constants â†’ camelCase (JavaScript/TypeScript standard).
Example: roomTimer, liveDuration, guestProfile.
	â€¢	Database columns â†’ snake_case only.
Example: created_at, updated_at, practitioner_id.
	â€¢	These three patterns must never overlap â€” verify across all files, APIs, schema, and frontend calls.
	3.	Single Source of Truth
	â€¢	Only one record per concept:
profiles for all user roles, sessions for all 1-on-1 and group data, reviews for feedback.
	â€¢	One /lib/config.ts file exporting all environment variables.
	â€¢	One shared type definition in /types â€” referenced everywhere (no duplicates in components).
	â€¢	All Supabase RLS policies, triggers, and schema definitions must align with this exact naming and type structure.
	4.	Environment Variables
	â€¢	Frontend â†’ VITE_ prefix for Replit or NEXT_PUBLIC_ for Vercel.
	â€¢	Backend â†’ plain names (no prefix).
	â€¢	Remove any duplicate or legacy variable names.
	5.	Folder Hierarchy

/app            â†’ Next.js routes
/api            â†’ API endpoints
/lib            â†’ utilities (Supabase client, Agora, logger)
/components     â†’ reusable UI elements
/types          â†’ TypeScript definitions
/tests          â†’ unit, integration, e2e
/styles         â†’ Tailwind setup
/sql            â†’ schema + migration scripts (must reflect UUID + naming standards)


	6.	Database Timestamps
	â€¢	Always created_at and updated_at (snake_case, lowercase).
	â€¢	Use default now() everywhere.
	7.	Timers & Rejoin Logic
	â€¢	The server time is the single truth. Clients only mirror.
	â€¢	Verify every countdown computation derives from server timestamps.

â¸»

ðŸ”· Testing & Debugging Infrastructure (Keep Fully Active)
	1.	Unit / Integration Tests
	â€¢	Use Vitest, @testing-library/react, and supertest.
	â€¢	Full coverage enabled (vitest --coverage).
	2.	E2E Tests
	â€¢	Use Playwright for signup/login, session start, rejoin, and timer flow verification.
	â€¢	Place all scripts in /tests/e2e.
	3.	Type Safety & Validation
	â€¢	strict: true in tsconfig.json.
	â€¢	Use Zod for runtime API payload validation.
	â€¢	ESLint + Prettier + Husky hooks to enforce formatting before commit.
	4.	Debug Tools
	â€¢	React Query Devtools.
	â€¢	Supabase realtime log console.
	â€¢	/lib/logger.ts for timestamped debug/info/warn/error logs.
	â€¢	Optional Sentry/OpenReplay for temporary runtime tracing.
	5.	Profiling & Diagnostics
	â€¢	Enable React Profiler.
	â€¢	/dev/inspector route: render time, latency, and timer drift stats.
	â€¢	logTimers() utility reporting sync drift every 10 seconds during tests.
	6.	Test Data Factories
	â€¢	/tests/factories: UUID-based mock generators (createPractitioner, createGuest, createSession).
	7.	Continuous Integration
	â€¢	GitHub Actions or Replit runner executes the full test suite on every commit.
	â€¢	Output coverage %, errors, and test time.

â¸»

ðŸ”· Final Verification & Schema Rebuild
	â€¢	Perform a full sweep of the app â€” every page, API, component, schema, and helper.
	â€¢	Ensure UUIDs, naming conventions, and type patterns are followed everywhere.
	â€¢	After verification, regenerate the entire SQL schema to reflect these rules perfectly (fresh migration, no legacy naming).
	â€¢	Rebuild Supabase tables to match the final schema and test all foreign key relationships again.

This check must be absolute â€” every inconsistency corrected before moving forward.
Once complete, the app will have a single coherent language and can evolve without naming or structural conflicts ever returning.