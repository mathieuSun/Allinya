Message to Replit

Please apply these permanent conventions and also initialize Allinya with a full professional-grade debugging and testing architecture from the very beginning. The intention is to keep the app completely minimalistic, coherent, and unified, while also making it fully observable and testable. Even if it feels heavy at first, this guarantees structural integrity and easy debugging later.

â¸»

ðŸ”· Global Structural & Naming Conventions
	1.	Database IDs
	â€¢	Every primary and foreign key across the app must use UUID.
	â€¢	No incremental IDs anywhere â€” everything universal and consistent.
	2.	Naming Convention
	â€¢	File, folder, and URL names â†’ kebab-case (kml case) (e.g. waiting-room, live-video).
	â€¢	Variables, functions, and constants â†’ camelCase (standard JS/TS).
	3.	Single Source of Truth
	â€¢	One table per concept (no duplicates).
	â€¢	profiles for all user roles, sessions for all live/waiting logic, etc.
	â€¢	One /lib/config.ts file re-exports all environment variables from process.env.
	â€¢	One environment variable per purpose â€” no duplicates or overlaps between client/server.
	4.	Folder Structure
	â€¢	/app â€” Next.js routes (App Router)
	â€¢	/api â€” backend endpoints
	â€¢	/lib â€” utilities (Supabase client, Agora, logger, helpers)
	â€¢	/components â€” UI blocks
	â€¢	/types â€” TypeScript definitions
	â€¢	/tests â€” all testing files (unit, integration, e2e)
	â€¢	/styles â€” Tailwind setup
	5.	Environment Variable Rules
	â€¢	Frontend vars â†’ VITE_ (for Replit) or NEXT_PUBLIC_ (for Vercel).
	â€¢	Server-only vars â†’ plain names (no prefix).
	6.	Database Timestamps
	â€¢	Always created_at and updated_at in lowercase snake_case, auto-generated with default now().
	7.	Timers & Rejoin Logic
	â€¢	The server timestamp is truth. Clients only mirror it. No secondary local timing states.

â¸»

ðŸ”· Full Expert-Level Testing & Debug Architecture
	1.	Unit & Integration Testing
	â€¢	Use Vitest (faster Jest alternative) with full coverage.
	â€¢	Add @testing-library/react for component testing.
	â€¢	Add supertest for API testing.
	â€¢	Store all tests in /tests/unit and /tests/integration.
	2.	End-to-End Testing (E2E)
	â€¢	Integrate Playwright for browser automation.
	â€¢	Preload flows: sign-up/login, toggle practitioner online, start/rejoin session.
	â€¢	Store under /tests/e2e.
	3.	Type Safety & Validation
	â€¢	Strict TypeScript ("strict": true in tsconfig.json).
	â€¢	Add Zod for runtime schema validation (API and forms).
	â€¢	Use ESLint + Prettier with Husky pre-commit hooks for consistent formatting.
	4.	Debug & Logging Tools
	â€¢	Integrate React Query Devtools.
	â€¢	Add Supabase Realtime console event logs for session phases.
	â€¢	Create /lib/logger.ts with debug/info/warn/error levels and timestamps.
	â€¢	Keep Next.js error overlay active in dev mode.
	â€¢	Optionally add Sentry or OpenReplay (temporary dev mode) for runtime tracing.
	5.	Performance Profiling
	â€¢	Enable React Profiler.
	â€¢	Add /dev/inspector route for render time, Supabase latency, and timer drift.
	â€¢	Add utility logTimers() that reports countdown drift every 10 seconds during test sessions.
	6.	Test Data Factories
	â€¢	Create /tests/factories folder with reusable builders:
createPractitioner(), createGuest(), createSession() (all UUID-based).
	7.	Continuous Integration (CI)
	â€¢	Add GitHub Actions (or Replit task runner) to execute full test suite on every commit.
	â€¢	Generate a summary: pass/fail, coverage %, and test time.

â¸»

ðŸ”· Overall Directive

Build Allinya using these conventions and tools so the project:
	â€¢	stays unified under one structural language,
	â€¢	can be debugged instantly from any layer (frontend, backend, realtime, or timer logic),
	â€¢	and provides complete observability for developers and future QA phases.

Once stability is confirmed, weâ€™ll safely remove or slim down the testing stack â€” but at the start, everything must be included and active to guarantee total clarity and speed in development.